IMPLEMENTA SEZIONE 2: Autenticazione Backend NULL

Contesto: Sistema autenticazione con JWT per NULL (Ecosistema Smart Locker Modulari). Frontend Flutter si aspetta login SPID/CIE (mock per ora, RF1 richiede SPID/CIE reali), JWT tokens, refresh token, endpoint /me. RNF4 richiede autenticazione forte, RNF5 richiede GDPR compliance.

Obiettivo: Implementare autenticazione completa - modello User, login mock SPID/CIE, JWT, middleware protezione, validazione, gestione privacy GDPR.

Stack: jsonwebtoken v9+, bcryptjs v2+ (opzionale), express-validator (già installato), Mongoose (già installato).

Struttura da creare:
backend/src/
├── models/User.js (Schema MongoDB utente - collezione "utente")
├── routes/auth.js (Route autenticazione)
├── controllers/authController.js (Logica business)
├── services/authService.js (Servizio JWT)
└── middleware/auth.js (Middleware protezione)

Requisiti dettagliati:

1. package.json: Aggiungi "jsonwebtoken": "^9.0.2", "bcryptjs": "^2.4.3" a dependencies, poi npm install

2. .env.example: Aggiungi JWT_SECRET (min 32 caratteri per RNF4), JWT_ACCESS_EXPIRES_IN=15m, JWT_REFRESH_EXPIRES_IN=7d

3. src/models/User.js: Schema Mongoose collezione "utente" con utenteId (unique indexed), nome (required), cognome (required), codiceFiscale (unique indexed uppercase), email (opz sparse), telefono (opz), dataRegistrazione Date default now, tipoAutenticazione enum ["spid","cie"] default "spid", ruolo enum ["utente","operatore","admin"] default "utente", attivo boolean default true, ultimoAccesso Date default now, refreshToken string (opz select:false). Metodi: toJSON() rimuove refreshToken e campi sensibili (GDPR RNF5), updateLastAccess(), virtual nomeCompleto. Index: utenteId unique, codiceFiscale unique. RF1: Supporto account "figli" per minori (campo opzionale genitoreId).

4. src/services/authService.js: generateTokens(user) genera access+refresh JWT, verifyToken(token, type) verifica JWT, generateAccessToken(user) solo access. Access token payload: {userId, utenteId, ruolo, iat, exp}. Refresh token payload: {userId, type:'refresh', iat, exp}. Usa JWT_SECRET da env, scadenze da JWT_ACCESS_EXPIRES_IN e JWT_REFRESH_EXPIRES_IN. RNF4: Token sicuri, non loggare mai tokens completi.

5. src/controllers/authController.js: login(req,res,next) valida input, cerca utente per codiceFiscale, se non esiste crea nuovo con utenteId sequenziale (USR-001, USR-002), genera tokens, aggiorna ultimoAccesso, ritorna {success:true, data:{user:{utenteId,nome,cognome,ruolo}, tokens:{accessToken,refreshToken,expiresIn}}}. refreshToken(req,res,next) valida refreshToken, verifica token, trova utente, genera nuovo access token, ritorna nuovo access. getMe(req,res,next) estrae userId da req.user, trova utente, ritorna info senza campi sensibili (GDPR). logout(req,res,next) invalida refresh token. RF1: Mock SPID/CIE per ora, in futuro integrare AgID.

6. src/middleware/auth.js: authenticate(req,res,next) estrae token da Authorization Bearer, verifica token, trova utente, verifica attivo, aggiunge req.user, chiama next(). Errori: token mancante→401, token invalido→401, utente non trovato→401, utente non attivo→403. RNF4: Rate limiting futuro per anti brute-force.

7. src/routes/auth.js: POST /api/v1/auth/login body {codiceFiscale (16 char A-Z0-9), tipoAutenticazione ["spid","cie"], nome?, cognome?} validazione express-validator, controller login. POST /api/v1/auth/refresh body {refreshToken} validazione, controller refreshToken. GET /api/v1/auth/me header Authorization Bearer, middleware authenticate, controller getMe. POST /api/v1/auth/logout header Authorization, middleware authenticate, controller logout.

8. src/server.js: Importa authRoutes, monta app.use('/api/v1/auth', authRoutes).

Validazione: express-validator per login (codiceFiscale required string length 16 pattern A-Z0-9, tipoAutenticazione required enum ["spid","cie"], nome/cognome optional string 1-100 char), refresh (refreshToken required string non vuoto). RNF4: Validazione input obbligatoria.

Errori: Usa UnauthorizedError(401), ValidationError(400), NotFoundError(404).

Flusso login mock: Client invia codiceFiscale+tipoAutenticazione, server cerca utente, se non esiste crea nuovo con utenteId sequenziale, genera tokens, aggiorna ultimoAccesso, ritorna tokens+user. RF1: In futuro integrare AgID per SPID/CIE reali.

Flusso refresh: Client invia refreshToken, server verifica, trova utente, genera nuovo access token, ritorna.

Flusso getMe: Client invia Authorization Bearer token, middleware verifica, estrae userId, trova utente, ritorna info (GDPR: solo dati necessari).

Testing: Testa login nuovo utente, login esistente, refresh token, get me con token, get me senza token (dovrebbe fallire 401).

Note: JWT_SECRET sicuro in produzione (32+ caratteri per RNF4), access token 15min, refresh 7 giorni, non loggare tokens (RNF4), utenteId sequenziale USR-001, refresh token in DB per revoca, GDPR compliance (RNF5): minimizzazione dati, pseudonimizzazione, diritti utente. RF1: Supporto account minori con genitoreId opzionale.

Output: Modello User funzionante (collezione "utente"), login mock JWT, refresh endpoint, middleware auth, endpoint /me, validazione, gestione errori, GDPR compliance base.

