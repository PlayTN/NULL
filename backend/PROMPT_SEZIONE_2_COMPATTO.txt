IMPLEMENTA SEZIONE 2: Autenticazione Backend NULL

Contesto: Sistema autenticazione con JWT per NULL. Frontend Flutter si aspetta login SPID/CIE (mock), JWT tokens, refresh token, endpoint /me.

Obiettivo: Implementare autenticazione completa - modello User, login mock, JWT, middleware protezione, validazione.

Stack: jsonwebtoken v9+, bcryptjs v2+ (opzionale), express-validator (già installato), Mongoose (già installato).

Struttura da creare:
backend/src/
├── models/User.js (Schema MongoDB utente)
├── routes/auth.js (Route autenticazione)
├── controllers/authController.js (Logica business)
├── services/authService.js (Servizio JWT)
└── middleware/auth.js (Middleware protezione)

Requisiti dettagliati:

1. package.json: Aggiungi "jsonwebtoken": "^9.0.2", "bcryptjs": "^2.4.3" a dependencies, poi npm install

2. .env.example: Aggiungi JWT_SECRET, JWT_ACCESS_EXPIRES_IN=15m, JWT_REFRESH_EXPIRES_IN=7d

3. src/models/User.js: Schema Mongoose con utenteId (unique), email (opz), nome, cognome, codiceFiscale (unique), tipoAutenticazione enum ["spid","cie"], ruolo enum ["utente","operatore","admin"] default "utente", attivo boolean default true, dataCreazione Date, ultimoAccesso Date, refreshToken string (opz). Metodi: toJSON() rimuove refreshToken, updateLastAccess(). Index: utenteId unique, codiceFiscale unique.

4. src/services/authService.js: generateTokens(user) genera access+refresh JWT, verifyToken(token, type) verifica JWT, generateAccessToken(user) solo access. Access token payload: {userId, utenteId, ruolo, iat, exp}. Refresh token payload: {userId, type:'refresh', iat, exp}. Usa JWT_SECRET da env, scadenze da JWT_ACCESS_EXPIRES_IN e JWT_REFRESH_EXPIRES_IN.

5. src/controllers/authController.js: login(req,res,next) valida input, cerca utente per codiceFiscale, se non esiste crea nuovo con utenteId sequenziale (USR-001, USR-002), genera tokens, aggiorna ultimoAccesso, ritorna {success:true, data:{user:{utenteId,nome,cognome,ruolo}, tokens:{accessToken,refreshToken,expiresIn}}}. refreshToken(req,res,next) valida refreshToken, verifica token, trova utente, genera nuovo access token, ritorna nuovo access. getMe(req,res,next) estrae userId da req.user, trova utente, ritorna info senza campi sensibili. logout(req,res,next) opzionale invalida refresh token.

6. src/middleware/auth.js: authenticate(req,res,next) estrae token da Authorization Bearer, verifica token, trova utente, verifica attivo, aggiunge req.user, chiama next(). Errori: token mancante→401, token invalido→401, utente non trovato→401, utente non attivo→403.

7. src/routes/auth.js: POST /api/v1/auth/login body {codiceFiscale, tipoAutenticazione, nome?, cognome?} validazione express-validator, controller login. POST /api/v1/auth/refresh body {refreshToken} validazione, controller refreshToken. GET /api/v1/auth/me header Authorization Bearer, middleware authenticate, controller getMe. POST /api/v1/auth/logout opzionale header Authorization, middleware authenticate, controller logout.

8. src/server.js: Importa authRoutes, monta app.use('/api/v1/auth', authRoutes).

Validazione: express-validator per login (codiceFiscale required string min16, tipoAutenticazione required enum ["spid","cie"], nome/cognome optional string), refresh (refreshToken required string non vuoto).

Errori: Usa UnauthorizedError(401), ValidationError(400), NotFoundError(404).

Flusso login mock: Client invia codiceFiscale+tipoAutenticazione, server cerca utente, se non esiste crea nuovo con utenteId sequenziale, genera tokens, aggiorna ultimoAccesso, ritorna tokens+user.

Flusso refresh: Client invia refreshToken, server verifica, trova utente, genera nuovo access token, ritorna.

Flusso getMe: Client invia Authorization Bearer token, middleware verifica, estrae userId, trova utente, ritorna info.

Testing: Testa login nuovo utente, login esistente, refresh token, get me con token, get me senza token (dovrebbe fallire 401).

Note: JWT_SECRET sicuro in produzione (32+ caratteri), access token 15min, refresh 7 giorni, non loggare tokens, utenteId sequenziale USR-001, refresh token opzionale in DB per revoca.

Output: Modello User funzionante, login mock JWT, refresh endpoint, middleware auth, endpoint /me, validazione, gestione errori.

